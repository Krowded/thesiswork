function [foundationStructs, connectionStructs] = addConnections(foundationStructs, connectionStructs, parts)    
    i = 1;
    while i <= length(connectionStructs)
        if isempty(connectionStructs(i).connectedWall)
            i = i+1;
            continue;
        end
        
        for j = 1:length(parts)
            if strcmp(parts{j}.name, connectionStructs(i).name)
                matchingPart = parts{j};
            end
        end
        
        %If no match found, ignore the connection
        if ~exist('matchingPart','var')
            warning(['Did not find any match for part [' char(connectionStructs(i).name) ']. Ignoring connection.'])
            connectionStructs(i) = [];
            continue;
        end
        
        %Parse connection
        connectedWall = connectionStructs(i).connectedWall;
        frontVector = connectionStructs(i).frontVector;
        upVector = connectionStructs(i).upVector;
        if isempty(upVector)
            warning('Connection lacking upVector. Using foundation upVector instead.');
            upVector = foundationStructs(1).upVector;
        end
        if isempty(frontVector)
            warning('Connection lacking frontVector. Using foundation frontVector instead.');
            frontVector = foundationStructs(1).frontVector;
        end
        
        %Match slots
        switch matchingPart.slotType
            case 'default'
                partSlots = (1:length(mathicngPart.slots,1));
                targetS
            case 'frontToFront'
                M = matchSlots(matchingPart.slots(1:4,:), connectionStructs(i).slots(1:4,:), 'non-uniform', frontVector, upVector);
            case 'backToBack'
                M = matchSlots(matchingPart.slots(5:8,:), connectionStructs(i).slots(5:8,:), 'non-uniform', frontVector, upVector);
            case 'frontToBack'
                M = matchSlots(matchingPart.slots(1:4,:), connectionStructs(i).slots(5:8,:), 'non-uniform', frontVector, upVector);
            case 'backToFront'
                M = matchSlots(matchingPart.slots(5:8,:), connectionStructs(i).slots(1:4,:), 'non-uniform', frontVector, upVector);
            otherwise
                warning(['Unknown slot type for adding connection on part ' char(matchingPart.name) ', slotType: ' char(matchingPart.slotType)]);
                M = matchSlots(matchingPart.slots, connectionStructs(i).slots, 'non-uniform', frontVector, upVector);
        end
        M = matchSlots(matchingPart.slots(partSlots,:), connectionStructs(i).slots(targetSlots,:), 'non-uniform', frontVector, upVector);
            
        if strcmp(connectionStructs(i).type, 'cut')
            %Get contour and move to wall
            newModelContour = matchingPart.contour;
            newModelContour = applyTransformation(newModelContour, M);

            %Constrain contour
            T = constrainContour(foundationStructs(connectedWall).vertices, newModelContour, upVector);
            newModelContour = applyTransformation(newModelContour, T);
            M = T*M;

            %Carve shape into wall
            [foundationStructs(connectedWall), connectionStructs(i).holeStruct] = createHoleFromContour(foundationStructs(connectedWall), newModelContour);
        end

        %Collect output parameters
        connectionStructs(i).transformationMatrix = M;
        
        i = i+1;
    end
end